%% == Erlang Compiler ==

{erl_opts, [debug_info, report, verbose, warnings_as_errors, {warn_format, 1}, warn_export_all,
            warn_export_vars, warn_obsolete_guard, warn_untyped_record, warn_unused_import,
            warn_shadow_vars]}.

%% == Dependencies ==

{deps, [{providers, "1.8.1"}]}.

%% == Plugins ==

{plugins, [{steamroll, {git, "https://github.com/old-reliable/steamroll.git", {branch, "master"}}},
           {rebar3_autotest, "0.1.1"}]}.

%% == Dialyzer ==

{dialyzer, [
            {warnings, [unknown]},
            %
            % Dialyzer will get upset if it has to analyse the provider.
            %
            % Tried adding 'rebar3' as a dep and to plt_extra_apps which seems like it should have
            % fixed the problem, but instead we get a load of 'Could not get Core Erlang code for:'
            % errors for all of the rebar3 beam files. Presumably because deps are compiled using
            % the prod profile and the rebar3 prod profile has 'no_debug_info'.
            %
            % Using `{overrides, [{override, rebar3, [{erl_opts, [debug_info]}]}]}.` seems to do
            % nothing.
            %
            % If you exclude only steamroll_prv then diazyler gets upset about steamroll:init
            % using an unknown function (steamroll_prv:init) so we exclude both.
            %
            % There must be an easy way to sort this out...
            %
            {plt_extra_apps, [providers]},
            {exclude_mods, [steamroll, steamroll_prv]}
           ]}.

%% == Aliases ==

{alias, [{check, [eunit, dialyzer]},
         {test, [eunit]}]}.

%% == Overrides ==

% This is a hack so that steamroll can use itself as a plugin.
% Create a symlink in $REPO/_checkouts to $REPO.
% By overriding the dep steamroll's plugins we prevent an infinite dep loop.
{overrides, [{override, steamroll, [{plugins, []}]}]}.
